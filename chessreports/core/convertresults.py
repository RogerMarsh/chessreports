# convertresults.py
# Copyright 2009 Roger Marsh
# Licence: See LICENCE (BSD licence)

"""Convert ECF submission files generated from same database.

This module allows event data held on a League database to be extracted
and prepared for import into a Berkeley DB or DPT results database. The
ECF submission file format is used to transfer the data because it is
the only output generated by any grading program in a known and fit for
purpose format.

The assumption necessary is that a PIN value refers to the same player
across submission files.

A restriction is that use of a PIN that looks like an ECF grading code is
sufficient to prevent this module making the assumption for the player.
(The League program does not use the grading code as PIN.)

BCF CODE; CLUB NAME; CLUB (non-standard for CLUB NAME); CLUB CODE;
and CLUB COUNTY fields on submission files are ignored.

Data compression uses bz2. Pickle is not used, before compression, to make
things a bit easier if the destination is not (otherwise) using Python.

(There is a data dump program for League databases and that format is
supported here. The data dump program is available to graders on request.
The only advantage from using this program is that all the data is in
a single file making it difficult to forget some data.)

"""

import os
import collections

from chessvalidate.core import gameresults

from . import matchteams
from . import constants as cc

# This should be used upstream but could not locate place.
homeplayerwhitemap = {True: "yes", False: "no"}


class ConvertResults(object):
    """Class for importing results data."""

    def __init__(self, pinprefix):
        """Initialise data structes for converting data to internal format."""
        super(ConvertResults, self).__init__()
        self.pinprefix = pinprefix
        self.converterror = None
        self.player = dict()
        self.game = dict()
        self.event = dict()
        self.match = dict()
        self.eventteams = dict()

    def cycle_name(self, name):
        """Generate versions of name starting with non-initials."""
        c = [name.split()]
        for e in range(len(c[-1]) - 1):
            n = c[-1][:]
            n.append(n.pop(0))
            c.append(n)
        return [" ".join(e) for e in c if len(e[0]) > 1 and not e[0].isupper()]

    def export_games(self, pins=False):
        """Generate list of game results in <field=value> format.

        Player pins can be used to merge players from different submission
        files if pins == True. Pin can always be used to merge players
        within a submission file (references to a player in different
        sections in an event). It is safe to use pins == True if it can be
        guaranteed that same pin means same player on all the submission
        files being processed.

        """
        items = (
            cc._startdate,
            cc._enddate,
            cc._event,
            cc._section,
            cc._date,
            # cc._homeplayerwhite,
            cc._homeplayer,
            cc._awayplayer,
        )
        if pins:
            pin_items = (
                (cc._homepin, cc._homepin),
                (cc._awaypin, cc._awaypin),
            )
        else:
            pin_items = (
                (cc._homepin, cc._homeserial),
                (cc._awaypin, cc._awayserial),
            )
        optional_items = (cc._hometeam, cc._awayteam, cc._board, cc._round)

        players = self.player
        matches = self.match
        exportgames = []
        for game in self.game.values():
            homeplayerwhite = homeplayerwhitemap.get(
                game.get(cc._gcolor, game.get(cc._homeplayerwhite)), ""
            )
            game[cc._homeplayerwhite] = homeplayerwhite
            homeaffiliation = players[
                get_player_identifier_from_game(
                    game, cc._homeplayer, cc._homeserial
                )
            ][cc._affiliation]
            awayaffiliation = players[
                get_player_identifier_from_game(
                    game, cc._awayplayer, cc._awayserial
                )
            ][cc._affiliation]
            sectionname = matches[game[cc._mcode]][cc._mname]
            uniquesection = game[cc._mcode]
            for i in items:
                exportgames.append("=".join((i, game[i])))
            for i, j in pin_items:
                exportgames.append("=".join((i, game[j])))
            for i in optional_items:
                e = game.get(i)
                if e is not None:
                    exportgames.append("=".join((i, e)))
            exportgames.append(
                "=".join((cc._homeplayerwhite, homeplayerwhite))
            )
            exportgames.append(
                "=".join((cc._homeaffiliation, homeaffiliation))
            )
            exportgames.append(
                "=".join((cc._awayaffiliation, awayaffiliation))
            )
            exportgames.append("=".join((cc._sectionname, sectionname)))
            exportgames.append("=".join((cc._uniquesection, uniquesection)))
            exportgames.append("=".join((cc._result, game[cc._result])))

        return exportgames

    def get_team_names_from_match_names(self):
        """Generate possible team names.

        Try to get team names from match name using the MatchTeams class.  If
        that fails use the TeamNames class to do the best possible by splitting
        the match name in two.

        MatchTeams, given enough consistent match names, will get team names
        'Team A' and 'Team B' from match name 'Team A - Team B' but TeamNames
        might get as far as team names 'Team A -' and 'Team B'.

        """
        hometeam = set()
        awayteam = set()
        for match in self.match.values():
            eventteams = self.eventteams.setdefault(match[cc._ecode], dict())
            matchteam = eventteams.setdefault(
                match[cc._mcode],
                matchteams.MatchTeams(
                    string=match[cc._mname],
                    split=match[cc._mtype] == cc._section_is_match,
                ),
            )
            for h, a in matchteam.teamsplits:
                if matchteam.position[h] == 0:
                    hometeam.add(h)
                    awayteam.add(a)
        teams = hometeam.intersection(awayteam)
        for eventteams in self.eventteams.values():
            for key, matchteam in eventteams.items():
                matchteam.teamsplits = tuple(
                    [
                        (h, a)
                        for h, a in matchteam.teamsplits
                        if h in teams and a in teams
                    ]
                )
                try:
                    self.match[key][cc._hometeam] = matchteam.teamsplits[-1][0]
                    self.match[key][cc._awayteam] = matchteam.teamsplits[-1][
                        -1
                    ]
                except:
                    teamnames = TeamNames(matchteam.string, teams)
                    matchteam.teamsplits = (
                        (teamnames(cc._hometeam), teamnames(cc._awayteam)),
                    )
                    self.match[key][cc._hometeam] = matchteam.teamsplits[-1][0]
                    self.match[key][cc._awayteam] = matchteam.teamsplits[-1][
                        -1
                    ]

    def add_match_section_to_events(self):
        """Generate section name for all matches in every event."""
        # collect all the non-match section names
        for match in self.match.values():
            if match[cc._mtype] != cc._section_is_match:
                event = self.event[match[cc._ecode]]
                sections = event.setdefault(cc._sections, [])
                if match[cc._mname] not in sections:
                    sections.append(match[cc._mname])
                else:
                    self.converterror = (
                        "Section name ",
                        match[cc._mname],
                        " duplicated in ",
                        event[cc._ename],
                        " event",
                    )
                    return self.empty_extract()

        # check that the system generated match section name is not used
        for match in self.match.values():
            if match[cc._mtype] == cc._section_is_match:
                event = self.event[match[cc._ecode]]
                sections = event.get(cc._sections, [])
                if cc._event_matches in sections:
                    self.converterror = (
                        "Section name for matches (",
                        cc._event_matches,
                        ") is already in ",
                        event[cc._ename],
                        " event. Change that section name to proceed.",
                    )
                    return self.empty_extract()

        # add the system generated match section to all events with matches
        for match in self.match.values():
            if match[cc._mtype] == cc._section_is_match:
                event = self.event[match[cc._ecode]]
                sections = event.setdefault(cc._sections, [])
                if cc._event_matches not in sections:
                    sections.append(cc._event_matches)
        self.get_team_names_from_match_names()
        return True

    def change_game_player_identifiers(self, game):
        """Change player id from <event, player> to <player, event, section>.

        one entry per player per event existed
        but need one entry per player per section per event
        copy player details from game to player for both players

        """
        match = self.match[game[cc._mcode]]
        if match[cc._mtype] == cc._section_is_match:
            eventsection = cc._event_matches
        else:
            eventsection = match[cc._mname]
        for gplayer, gserial, side, pin, pcode in (
            (cc._homeplayer, cc._homeserial, 0, cc._homepin, cc._pcode1),
            (cc._awayplayer, cc._awayserial, -1, cc._awaypin, cc._pcode2),
        ):
            player = self.player.setdefault(
                get_player_identifier_from_game(game, gplayer, gserial), {}
            )
            self.set_player_detail(player, game, gplayer, pin)
            # add game details to team and affiliation derivation data
            self.set_potential_names(
                player,
                side,
                self.eventteams[match[cc._ecode]][game[cc._mcode]],
                eventsection,
            )

    def copy_event_and_player_identifiers_to_games(self):
        """Copy identifiers to games."""
        # copy event and player identifiers to game
        for game in self.game.values():
            match = self.match[game[cc._mcode]]
            event = self.event[match[cc._ecode]]
            for a in cc._event, cc._startdate, cc._enddate:
                game[a] = event[a]
            s = match[cc._mname]
            is_match = match[cc._mtype] == cc._section_is_match
            if is_match:
                game[cc._section] = cc._event_matches
            else:
                game[cc._section] = s
            c = game.get(cc._gcolor, None)
            if c == cc.WHITE:
                game[cc._homeplayerwhite] = cc._yes
            elif c == cc.BLACK:
                game[cc._homeplayerwhite] = cc._no
            else:
                game[cc._homeplayerwhite] = cc.NOCOLOR
            for player, pin, serial, pcode in (
                (cc._homeplayer, cc._homepin, cc._homeserial, cc._pcode1),
                (cc._awayplayer, cc._awaypin, cc._awayserial, cc._pcode2),
            ):
                game[player] = self.player[game[pcode]][cc._player]
                game[pin] = self.player[game[pcode]][cc._pcode]
                game[serial] = self.player[game[pcode]][cc._serial]
        return True

    def empty_extract(self):
        """Clear data structures."""
        self.player.clear()
        self.game.clear()
        self.event.clear()
        self.match.clear()
        self.eventteams.clear()
        return False

    def translate_results_format(
        self,
        context=None,
        keymap=None,
        validmap=None,
        pinreadmap=None,
        pinmap=None,
        gradingcodemap=None,
    ):
        """Extract results into a common format.

        Provide rules in context and keymap arguments.

        """

        def null(data, context):
            pass

        process = null

        if context is None:
            context = dict()
        for c in context:
            if not isinstance(context[c], collections.abc.Callable):
                context[c] = null
        if keymap is None:
            keymap = dict()
        if validmap is None:
            validmap = dict()
        if pinreadmap is None:
            pinreadmap = set()
        if pinmap is None:
            pinmap = set()
        if gradingcodemap is None:
            gradingcodemap = set()

        pinvaluemap = dict()
        data = dict()
        for e, t in enumerate(self.get_lines()):
            ts = t.split("=", 1)
            key, value = ts[0], ts[-1]
            if key not in validmap:
                if len(key) != 0:
                    self.converterror = ("Keyword not expected : ", key)
                    return self.empty_extract()
            else:
                vm = validmap[key]
                if isinstance(vm, str):
                    if contextkey != vm:
                        self.converterror = (
                            "Keyword ",
                            key,
                            " not expected after keyword ",
                            contextkey,
                        )
                        return self.empty_extract()
                elif isinstance(vm, dict):
                    try:
                        if contextkey not in vm:
                            self.converterror = (
                                "Keyword ",
                                key,
                                " not expected after keyword ",
                                contextkey,
                            )
                            return self.empty_extract()
                    except:
                        self.converterror = (
                            "Keyword ",
                            key,
                            " not expected before context determined",
                        )
                        return self.empty_extract()
                elif vm is not None:
                    self.converterror = (
                        "Unable to determine validity of keyword ",
                        key,
                    )
                    return self.empty_extract()
            if key in context:
                if len(data):
                    process(data, contextkey)
                process = context[key]
                data = dict()
                contextkey = key
            if key in keymap:
                if key in pinmap:
                    if value not in pinvaluemap:
                        if len(value) != cc.GRADING_CODE_LENGTH:
                            pinvaluemap[value] = value
                        elif (
                            value[-1] in cc.GRADING_CODE_CHECK_CHARACTERS
                            and value[:-1].isdigit()
                        ):
                            pinvaluemap[value] = "-".join(
                                (self.pinprefix, str(len(pinvaluemap)))
                            )
                        else:
                            pinvaluemap[value] = value
                if key in pinreadmap:
                    data[keymap[key]] = pinvaluemap[value]
                else:
                    data[keymap[key]] = value
            elif key in gradingcodemap:
                if cc._pcode in data:
                    if len(value) == cc.GRADING_CODE_LENGTH:
                        if value[:-1] in data[cc._pcode]:
                            self.converterror = (
                                "Grading code ",
                                value,
                                " is included in player pin ",
                                data[cc._pcode],
                            )
                            return self.empty_extract()

        if len(data):
            process(data, contextkey)

        self.prune(self.match, self.game, cc._mcode)
        self.prune(self.event, self.match, cc._ecode)
        return True

    def get_game_players(self):
        """Return the set of players who have played games."""
        gplayers = set()
        codes = (cc._pcode1, cc._pcode2)
        for g in self.game.values():
            for pc in codes:
                if pc in g:
                    gplayers.add(g[pc])
        return gplayers

    def prune(self, target, source, attr):
        """Remove objects from target not referenced by source using attr."""
        used = set()
        for v in source.values():
            if attr in v:
                if v[attr] in target:
                    used.add(v[attr])
        for p in list(target.keys()):
            if p not in used:
                del target[p]

    def prune_players(self, gameplayers):
        """Remove players who have not played any games."""
        for k in list(self.player.keys()):
            if k not in gameplayers:
                del self.player[k]

    def rebuild_player_data(self):
        """Change player identity to <player, event, section>."""
        # copy event and player identifiers to game
        self.player.clear()
        for game in self.game.values():
            self.change_game_player_identifiers(game)

    def report_games(self):
        """Report all games and games for players with affiliation doubts.

        All games sorted by event and section.
        Games for players with affiliation doubts sorted by player.

        """
        gamesbysection = dict()
        problemplayers = dict()

        for k, game in self.game.items():
            section = gamesbysection.setdefault(
                (
                    game[cc._startdate],
                    game[cc._enddate],
                    game[cc._event],
                    game[cc._section],
                    game[cc._mcode],
                ),
                [],
            )
            section.append(k)
            if self.match[game[cc._mcode]][cc._mtype] != cc._section_is_match:
                continue
            for teamplayer, teamserial, team in (
                (cc._homeplayer, cc._homeserial, cc._hometeam),
                (cc._awayplayer, cc._awayserial, cc._awayteam),
            ):
                p = get_player_identifier_from_game(
                    game, teamplayer, teamserial
                )
                if self.player[p][cc._affiliation] not in game[team]:
                    pp = problemplayers.setdefault(p, set())
                    pp.add(k)

        lines = []
        for gbs in sorted(gamesbysection):
            home = away = ""
            sectiongames = []
            for g in gamesbysection[gbs]:
                game = self.game[g]
                if not home:
                    if cc._hometeam in game:
                        home = game[cc._hometeam]
                if not away:
                    if cc._awayteam in game:
                        away = game[cc._awayteam]
                sectiongames.append(
                    "".join(
                        (
                            "\t\t",
                            game[cc._homeplayer],
                            "\t\t\t",
                            self.player[
                                get_player_identifier_from_game(
                                    game, cc._homeplayer, cc._homeserial
                                )
                            ][cc._affiliation],
                            "\t\t\t",
                            gameresults.storeresults[game[cc._result]],
                            "\t\t",
                            game[cc._awayplayer],
                            "\t\t\t",
                            self.player[
                                get_player_identifier_from_game(
                                    game, cc._awayplayer, cc._awayserial
                                )
                            ][cc._affiliation],
                            "\t\t\t",
                            game[cc._date],
                        )
                    )
                )
            lines.append(
                "\n".join(
                    (
                        "\t\t".join(gbs[:-1]),
                        "\t\t".join(("\t\t\t", home, "\t\t\t\t", away)),
                        "\n".join(sectiongames),
                    )
                )
            )

        gamesreport = "\n\n".join(lines)

        lines = []
        for name, pp in sorted(
            [
                (self.player[p][cc._player], p)
                for p in list(problemplayers.keys())
            ]
        ):
            playergames = []
            player = "".join(
                (
                    name,
                    "\t\t\t",
                    self.player[pp][cc._affiliation],
                    "\t\t\t",
                    self.player[pp][cc._startdate],
                    " ",
                    self.player[pp][cc._enddate],
                    "\t\t\t",
                    self.player[pp][cc._event],
                )
            )
            for pg in problemplayers[pp]:
                game = self.game[pg]
                playergames.append(
                    "".join(
                        (
                            "\t\t\t",
                            game[cc._date],
                            "\t\t\t",
                            game[cc._homeplayer],
                            "\t\t\t",
                            game[cc._hometeam],
                            "\t\t\t",
                            game[cc._awayteam],
                            "\t\t\t",
                            game[cc._awayplayer],
                        )
                    )
                )
            lines.append("\n".join((player, "\n".join(playergames))))

        playergamesreport = "\n\n".join(lines)

        playeraffiliations = []
        for k, v in self.player.items():
            startdate, enddate, event, player, section, serial = k
            affiliation = v[cc._affiliation]
            for p in self.cycle_name(player):
                playeraffiliations.append(
                    (
                        p,
                        affiliation,
                        startdate,
                        enddate,
                        event,
                        section,
                        serial,
                    )
                )
        playeraffiliations.sort()

        playeraffiliationreport = "\n".join(
            [
                "\t\t".join((p, "\t", a, "\t", sd, ed, e, "\t", s))
                for p, a, sd, ed, e, s, sn in playeraffiliations
            ]
        )

        events = []
        for e in self.event.values():
            events.append(
                (
                    e[cc._startdate],
                    e[cc._enddate],
                    e[cc._event],
                    e[cc._sections],
                )
            )
        events.sort()

        eventreport = "\n".join(
            [
                "".join(
                    (
                        sd,
                        "\t\t",
                        ed,
                        "\t\t",
                        e,
                        "\n\t\t\t\t",
                        "\n\t\t\t\t".join([s for s in sections]),
                        "\n",
                    )
                )
                for sd, ed, e, sections in events
            ]
        )

        return (
            eventreport,
            playeraffiliationreport,
            playergamesreport,
            gamesreport,
        )

    def set_player_detail(self, player, game, gplayer, gpin):
        """Copy name and pin detail from game to player."""
        if not player:
            player[cc._player] = game[gplayer]
            player[cc._pin] = game[gpin]
            for a in cc._event, cc._section, cc._startdate, cc._enddate:
                player[a] = game[a]

    def set_potential_names(self, player, side, eventteams, section):
        """Add potential team names and affiliations to player[cc._names]."""
        names = player.setdefault(cc._names, {})
        names[section] = names.setdefault(section, {})
        phrases = dict()
        for ts in eventteams.teamsplits:
            phrases[ts[side]] = phrases.setdefault(ts[side], 0) + 1
        for p in phrases:
            counter = names[section].setdefault(p, PhraseCounts(p))
            if side == 0:
                counter += 1
            else:
                counter += 1

    def set_team_names_and_affiliations(self):
        """Derive player's affiliation from sections (matches) played."""
        teams = set()
        for eps, player in self.player.items():
            # pick most common phrase as player affiliation
            # if it is not the match name it is a potential team name
            for phrases in player[cc._names].values():
                phrase = sorted(
                    [(c.get_weight(), c) for c in phrases.values()],
                    reverse=True,
                )[0][-1]
                player[cc._affiliation] = phrase.chars
                if not phrase.equal:
                    teams.add(phrase.chars)
                # remove if not finished with deleted names
                player[cc._names] = [c for c in phrases.values() if c.equal]

        # pick team names that are best fit to match name as affiliations
        for eps, player in self.player.items():
            if eps[-1] != cc._event_matches:
                continue
            # affiliation is a match name or a team name
            # find best match between affiliation and potential team names
            # if there is a best match make that the affiliation
            # if not (it is a tie) set affiliation to the choices
            affiliation = player[cc._affiliation]
            if affiliation not in player[cc._names]:
                if affiliation in teams:
                    # affiliation is a team so nothing needs doing
                    continue
            # find most common home or away team name in affiliation
            w = affiliation.split()
            ateam = None
            hteam = None
            for i in range(1, len(w) + 1):
                t = " ".join(w[:i])
                if t in teams:
                    hteam = t
                t = " ".join(w[-i:])
                if t in teams:
                    ateam = t
            tcounts = {}
            for phrase in player[cc._names]:
                for t in ateam, hteam:
                    if t:
                        if t in phrase.chars:
                            tcounts[t] = tcounts.setdefault(t, 0) + 1
            # adjust the affiliation
            if tcounts.get(ateam, 0) > tcounts.get(hteam, 0):
                player[cc._affiliation] = ateam
            elif tcounts.get(hteam, 0) > tcounts.get(ateam, 0):
                player[cc._affiliation] = hteam
            else:
                player[cc._affiliation] = (hteam, ateam)

        # set team names for game
        match = self.match
        for game in self.game.values():
            if match[game[cc._mcode]][cc._mtype] != cc._section_is_match:
                continue
            for team in cc._hometeam, cc._awayteam:
                game[team] = match[game[cc._mcode]][team]

        # where player affiliation has not been resolved to a team name use
        # the last suitable game team name encountered as affiliation but
        # give priority to a name in the affiliation tuple
        for game in self.game.values():
            if self.match[game[cc._mcode]][cc._mtype] != cc._section_is_match:
                continue
            # set player affiliation same as game team
            event = self.match[game[cc._mcode]][cc._ecode]
            section = game[cc._section]
            for teamplayer, team, pin, serial in (
                (cc._homeplayer, cc._hometeam, cc._homepin, cc._homeserial),
                (cc._awayplayer, cc._awayteam, cc._awaypin, cc._awayserial),
            ):
                player = self.player[
                    get_player_identifier_from_game(game, teamplayer, serial)
                ]
                if isinstance(player[cc._affiliation], str):
                    # affiliation already set
                    continue
                player[cc._affiliation] = game[team]


class ConvertSubmissionFile(ConvertResults):
    """Import data from file formatted as ECF results submission file."""

    results = {
        cc.RESULT_01: cc.AWIN,  # cc._loss,
        cc.RESULT_55: cc.DRAW,  # cc._draw,
        cc.RESULT_10: cc.HWIN,  # cc._win,
    }
    colour = {
        cc.ECF_COLOUR_WHITE: True,  # cc.WHITE,
        cc.ECF_COLOUR_BLACK: False,  # cc.BLACK,
        cc.ECF_COLOUR_W: True,  # cc.WHITE,
        cc.ECF_COLOUR_B: False,  # cc.BLACK,
    }
    colourdefault = {
        cc.ECF_COLOURDEFAULT_ALL: cc.WHITE_ON_ALL,
        cc.ECF_COLOURDEFAULT_EVEN: cc.BLACK_ON_ODD,
        cc.ECF_COLOURDEFAULT_NONE: cc.BLACK_ON_ALL,
        cc.ECF_COLOURDEFAULT_ODD: cc.WHITE_ON_ODD,
        cc.ECF_COLOURDEFAULT_UNKNOWN: cc.COLOR_NOT_SPECIFIED,
    }

    def translate_results_format(self):
        """Translate results to internal format."""

        def convert_colour_text(data):
            # try:
            # data[cc._gcolor] = ConvertSubmissionFile.colour[
            # data[cc._gcolor].lower()]
            # except:
            # data[cc._gcolor] = cc.NOCOLOR
            try:
                data[cc._gcolor] = ConvertSubmissionFile.colour[
                    data[cc._gcolor].lower()
                ]
            except:
                data[cc._gcolor] = None  # cc.NOCOLOR

        def convert_colour_default_text(data):
            try:
                data[cc._mcolor] = ConvertSubmissionFile.colourdefault[
                    data[cc._mcolor].lower()
                ]
            except:
                data[cc._mcolor] = cc.NOCOLOR

        def convert_result_text(data):
            try:
                data[cc._gresult] = ConvertSubmissionFile.results[
                    data[cc._gresult]
                ]
            except:
                data[cc._gresult] = cc.VOID

        def get_event(data, context):
            k = str(len(self.event) + 1)
            self.event[k] = data
            if cc._ecode in data:
                data[cc._ecode] = k
            convert_date_to_iso(data, cc._edate)
            convert_date_to_iso(data, cc._efinaldate)

        def get_game(data, context):
            convert_result_text(data)
            if (
                data[cc._gresult] in gameresults.storeresults
            ):  # cc._storeresults:
                k = str(len(self.game) + 1)
                self.game[k] = data
                data[cc._gcode] = k
                data[cc._mcode] = str(len(self.match))
                e = str(len(self.event))
                for p in (cc._pcode1, cc._pcode2):
                    data[p] = (e, data[p])
                convert_date_to_iso(data, cc._gdate)
                convert_colour_text(data)

        def get_match(data, context):
            k = str(len(self.match) + 1)
            self.match[k] = data
            data[cc._mcode] = k
            data[cc._ecode] = str(len(self.event))
            if context in sectiontypemap:
                data[cc._mtype] = sectiontypemap[context]
            convert_date_to_iso(data, cc._mdate)
            convert_colour_default_text(data)

        def get_player(data, context):
            self.player[(str(len(self.event)), data[cc._pcode])] = data
            data[cc._serial] = str(len(self.player))
            if cc._cname in data:
                if data[cc._cname][-1] == "*":
                    data[cc._cname] = data[cc._cname][:-1].strip()
            if cc._pname not in data:
                if cc._surname in data:
                    data[cc._pname] = " ".join(
                        (
                            "".join((data.get(cc._surname, ""), ",")),
                            " ".join(
                                (
                                    data.get(cc._forename, ""),
                                    data.get(cc._initials, ""),
                                )
                            ).strip(),
                        )
                    ).strip()

        context = {
            cc.EVENT_DETAILS: get_event,
            cc.PLAYER_LIST: get_player,
            cc.OTHER_RESULTS: get_match,
            cc.MATCH_RESULTS: get_match,
            cc.SECTION_RESULTS: get_match,
            cc.FINISH: None,
            cc.PIN: get_player,
            cc.PIN1: get_game,
        }

        keymap = {
            cc.EVENT_CODE: cc._ecode,
            cc.EVENT_NAME: cc._ename,
            cc.EVENT_DATE: cc._edate,
            cc.FINAL_RESULT_DATE: cc._efinaldate,
            cc.PIN: cc._pcode,
            cc.NAME: cc._pname,
            cc.OTHER_RESULTS: cc._mname,
            cc.MATCH_RESULTS: cc._mname,
            cc.SECTION_RESULTS: cc._mname,
            cc.RESULTS_DATE: cc._mdate,
            cc.PIN1: cc._pcode1,
            cc.PIN2: cc._pcode2,
            cc.ROUND: cc._ground,
            cc.BOARD: cc._gboard,
            cc.COLOUR: cc._gcolor,
            cc.SCORE: cc._gresult,
            cc.GAME_DATE: cc._gdate,
            cc.WHITE_ON: cc._mcolor,
            # cc.CLUB:cc._cname, #League program for CLUB NAME
            # cc.CLUB_NAME:cc._cname,
            cc.SURNAME: cc._surname,
            cc.INITIALS: cc._initials,
            cc.FORENAME: cc._forename,
        }

        sectiontypemap = {
            cc.OTHER_RESULTS: cc.OTHER_TYPE,
            cc.MATCH_RESULTS: cc.LEAGUE_MATCH_TYPE,
            cc.SECTION_RESULTS: cc.TOURNAMENT_TYPE,
        }

        """
        validmap rejects at least one field that is mandatory on a valid
        submission file, SUBMISSION_INDEX, and at least one set from which one
        will be present on a valid submission file, BCF_CODE CLUB_NAME or CLUB,
        for each player.
        """
        # validmap should be identical to version in preparesource.py with
        # relevant entries commented out.
        validmap = {
            # cc.ADJUDICATED:cc.EVENT_DETAILS,
            # cc.BCF_CODE:cc.PIN,
            # cc.BCF_NO:cc.PIN,
            cc.BOARD: {
                cc.MATCH_RESULTS: None,
                cc.PIN1: None,
            },
            # cc.CLUB:cc.PIN, #League program for CLUB NAME
            # cc.CLUB_CODE:cc.PIN,
            # cc.CLUB_COUNTY:cc.PIN,
            # cc.CLUB_NAME:cc.PIN,
            cc.COLOUR: {
                cc.MATCH_RESULTS: None,
                cc.SECTION_RESULTS: None,
                cc.OTHER_RESULTS: None,
                cc.PIN1: None,
            },
            # cc.COMMENT:{
            # cc.PIN:None,
            # cc.MATCH_RESULTS:None,
            # cc.SECTION_RESULTS:None,
            # },
            # cc.DATE_OF_BIRTH:cc.PIN,
            cc.EVENT_CODE: cc.EVENT_DETAILS,
            cc.EVENT_DATE: cc.EVENT_DETAILS,
            cc.EVENT_DETAILS: None,
            cc.EVENT_NAME: cc.EVENT_DETAILS,
            # cc.FIDE_NO:cc.PIN,
            cc.FINAL_RESULT_DATE: cc.EVENT_DETAILS,
            cc.FINISH: None,
            cc.FORENAME: cc.PIN,
            cc.GAME_DATE: {
                cc.MATCH_RESULTS: None,
                cc.SECTION_RESULTS: None,
                cc.OTHER_RESULTS: None,
                cc.PIN1: None,
            },
            # cc.GENDER:cc.PIN,
            # cc.INFORM_CHESSMOVES:cc.EVENT_DETAILS,
            # cc.INFORM_FIDE:cc.EVENT_DETAILS,
            # cc.INFORM_GRAND_PRIX:cc.EVENT_DETAILS,
            # cc.INFORM_UNION:cc.EVENT_DETAILS,
            cc.INITIALS: cc.PIN,
            cc.MATCH_RESULTS: None,
            # cc.MINUTES_FIRST_SESSION:cc.EVENT_DETAILS,
            # cc.MINUTES_FOR_GAME:cc.EVENT_DETAILS,
            # cc.MINUTES_REST_OF_GAME:cc.EVENT_DETAILS,
            # cc.MINUTES_SECOND_SESSION:cc.EVENT_DETAILS,
            # cc.MOVES_FIRST_SESSION:cc.EVENT_DETAILS,
            # cc.MOVES_SECOND_SESSION:cc.EVENT_DETAILS,
            cc.NAME: cc.PIN,
            cc.OTHER_RESULTS: None,
            cc.PIN: {
                cc.PLAYER_LIST: None,
                cc.PIN: None,
            },
            cc.PIN1: {
                cc.MATCH_RESULTS: None,
                cc.SECTION_RESULTS: None,
                cc.OTHER_RESULTS: None,
                cc.PIN1: None,
            },
            cc.PIN2: {
                cc.MATCH_RESULTS: None,
                cc.SECTION_RESULTS: None,
                cc.OTHER_RESULTS: None,
                cc.PIN1: None,
            },
            cc.PLAYER_LIST: None,
            cc.RESULTS_DATE: {
                cc.MATCH_RESULTS: None,
                cc.SECTION_RESULTS: None,
            },
            # cc.RESULTS_DUPLICATED:cc.EVENT_DETAILS,
            # cc.RESULTS_OFFICER:cc.EVENT_DETAILS,
            # cc.RESULTS_OFFICER_ADDRESS:cc.EVENT_DETAILS,
            cc.ROUND: {
                cc.SECTION_RESULTS: None,
                cc.PIN1: None,
            },
            cc.SCORE: {
                cc.MATCH_RESULTS: None,
                cc.SECTION_RESULTS: None,
                cc.OTHER_RESULTS: None,
                cc.PIN1: None,
            },
            # cc.SECONDS_PER_MOVE:cc.EVENT_DETAILS,
            cc.SECTION_RESULTS: None,
            # cc.SUBMISSION_INDEX:cc.EVENT_DETAILS,
            cc.SURNAME: cc.PIN,
            # cc.TITLE:cc.PIN,
            # cc.TREASURER:cc.EVENT_DETAILS,
            # cc.TREASURER_ADDRESS:cc.EVENT_DETAILS,
            cc.WHITE_ON: {
                cc.MATCH_RESULTS: None,
                cc.SECTION_RESULTS: None,
                cc.OTHER_RESULTS: None,
            },
        }

        extract = super(ConvertSubmissionFile, self).translate_results_format(
            context=context,
            keymap=keymap,
            validmap=validmap,
            pinreadmap={cc.PIN, cc.PIN1, cc.PIN2},
            pinmap={cc.PIN},
            gradingcodemap={cc.BCF_CODE},
        )

        if not extract:
            return False

        self.prune_players(self.get_game_players())

        if not self.add_match_section_to_events():
            return False

        if not self.copy_event_and_player_identifiers_to_games():
            return False

        self.rebuild_player_data()

        self.set_team_names_and_affiliations()

        return extract


class ConvertLeagueDump(ConvertResults):
    """Import data from dump of League program database."""

    results = {
        cc.result_0: cc.TBR,
        cc.result_1: cc.AWIN,  # cc._loss,
        cc.result_2: cc.DRAW,  # cc._draw,
        cc.result_3: cc.HWIN,  # cc._win,
        cc.result_4: cc.AWAYDEFAULT,
        cc.result_5: cc.HOMEDEFAULT,
        cc.result_6: cc.VOID,
        cc.result_7: cc.WINBYE,
        cc.result_8: cc.DRAWBYE,
    }
    colour = {
        cc.colour_1: True,  # cc.WHITE,
        cc.colour_2: False,  # cc.BLACK,
        cc.colour_0: None,  # cc.NOCOLOR,
    }
    colourdefault = {
        cc.colourdefault_1: cc.WHITE_ON_ALL,
        cc.colourdefault_4: cc.BLACK_ON_ODD,
        cc.colourdefault_0: cc.COLOR_NOT_SPECIFIED,
        cc.colourdefault_2: cc.WHITE_ON_ODD,
        cc.colourdefault_3: cc.BLACK_ON_ALL,
    }

    def __init__(self, pinprefix):
        """Initialise data structures."""
        super(ConvertLeagueDump, self).__init__(pinprefix=pinprefix)
        self.affiliate = dict()
        self.club = dict()
        self.represent = set()
        self.team = dict()

    def empty_extract(self):
        """Clear data structures."""
        self.affiliate.clear()
        self.club.clear()
        self.represent.clear()
        self.team.clear()
        return super(ConvertLeagueDump, self).empty_extract()

    def translate_match_field(self):
        """Translate matches to internal format."""
        fixturelines = []
        reportlines = []
        matchresults = {}
        for tf in sorted(self.files):
            mname = ""
            fi = open(tf, "r")  # 'r' or 'rb'?
            try:
                for tt in fi:
                    ts = tt.split("=", 1)
                    f = ts[0]
                    if f == cc._mname:
                        mname = ts[-1]
                    elif f == cc._mtype:
                        if ts[-1].rstrip() == cc._section_is_match:
                            mn = "_".join(
                                (cc.TAKEON_MATCH, str(len(matchresults) + 1))
                            )
                            fixturelines.append("=".join((mn, mname.rstrip())))
                            reportlines.append("=".join((f, mn.rstrip())))
                            matchresults[mn] = (
                                len(fixturelines),
                                len(reportlines),
                            )
                        else:
                            reportlines.append(tt.rstrip())
                    else:
                        reportlines.append(tt.rstrip())
            finally:
                fi.close()
        return (fixturelines, reportlines, matchresults)

    def translate_results_format(self):
        """Translate results to internal format."""

        def get_affiliate(data, context):
            self.affiliate[(data[cc._ecode], data[cc._pcode])] = data
            if cc._pname in data:
                del data[cc._pname]
            if cc._edate in data:
                del data[cc._edate]

        def get_club(data, context):
            self.club[data[cc._ccode]] = data
            if cc._cname in data:
                if data[cc._cname][-1] == "*":
                    data[cc._cname] = data[cc._cname][:-1].strip()

        def convert_colour_text(data):
            try:
                data[cc._gcolor] = ConvertLeagueDump.colour[data[cc._gcolor]]
            except:
                data[cc._gcolor] = cc.NOCOLOR

        def convert_colour_default_text(data):
            try:
                data[cc._mcolor] = ConvertLeagueDump.colourdefault[
                    data[cc._mcolor].lower()
                ]
            except:
                data[cc._mcolor] = cc.NOCOLOR

        def convert_result_text(data):
            try:
                data[cc._gresult] = ConvertLeagueDump.results[
                    data[cc._gresult]
                ]
            except:
                data[cc._gresult] = cc.VOID

        def get_event(data, context):
            self.event[data[cc._ecode]] = data
            convert_date_to_iso(data, cc._edate)
            convert_date_to_iso(data, cc._efinaldate)

        def get_game(data, context):
            convert_result_text(data)
            if (
                data[cc._gresult] in gameresults.storeresults
            ):  # cc._storeresults:
                self.game[data[cc._gcode]] = data
                convert_date_to_iso(data, cc._gdate)
                convert_colour_text(data)

        def get_match(data, context):
            self.match[data[cc._mcode]] = data
            convert_date_to_iso(data, cc._mdate)
            convert_colour_default_text(data)

        def get_player(data, context):
            self.player[data[cc._pcode]] = data
            data[cc._serial] = str(len(self.player))
            lnn = int(data[cc._plennickname])
            lfn = int(data[cc._plenforename])
            n = data[cc._pname]
            if lnn and lfn:
                data[cc._pname] = " ".join(
                    ("".join((n[: -lfn - lnn - 4], ",")), n[-lfn - lnn - 3 :])
                )
            elif lfn:
                data[cc._pname] = " ".join(
                    ("".join((n[: -lfn - 1], ",")), n[-lfn:])
                )
            elif lnn:
                data[cc._pname] = " ".join(
                    ("".join((n[: -lnn - 3], ",")), n[-lnn - 2 :])
                )

        def get_represent(data, context):
            self.represent.add((data[cc._tcode], data[cc._pcode]))

        def get_team(data, context):
            self.team[data[cc._tcode]] = data

        context = {
            # cc.represent:get_represent,
            # cc.club:None,
            cc.player: get_player,
            cc.game: get_game,
            # cc.affiliate:None,
            cc.team: get_team,
            cc.event: get_event,
            cc.match: get_match,
        }

        keymap = {
            cc.ECODE: cc._ecode,
            cc.ENAME: cc._ename,
            cc.EDATE: cc._edate,
            cc.EFINALDATE: cc._efinaldate,
            cc.PCODE: cc._pcode,
            cc.PNAME: cc._pname,
            cc.MCODE: cc._mcode,
            cc.MNAME: cc._mname,
            cc.MDATE: cc._mdate,
            cc.PCODE1: cc._pcode1,
            cc.PCODE2: cc._pcode2,
            cc.GCODE: cc._gcode,
            cc.GROUND: cc._ground,
            cc.GBOARD: cc._gboard,
            cc.GCOLOR: cc._gcolor,
            cc.GRESULT: cc._gresult,
            cc.GDATE: cc._gdate,
            cc.MCOLOR: cc._mcolor,
            cc.MTYPE: cc._mtype,
            # cc.CCODE:cc._ccode,
            # cc.CNAME:cc._cname,
            cc.TCODE: cc._tcode,
            cc.TNAME: cc._tname,
            # cc.RPAIRING:cc._rpairing,
            cc.TCODE1: cc._tcode1,
            cc.TCODE2: cc._tcode2,
            cc.PLENFORENAME: cc._plenforename,
            cc.PLENNICKNAME: cc._plennickname,
        }

        validmap = {
            cc.ECODE: {cc.event: None, cc.match: None, cc.affiliate: None},
            cc.ENAME: cc.event,
            # cc.EBCF:cc.event,
            cc.EDATE: {cc.event: None, cc.affiliate: None},
            cc.EFINALDATE: cc.event,
            # cc.ESUBMISSION:cc.event,
            # cc.ETREASURER:cc.event,
            # cc.EADDRESS1:cc.event,
            # cc.EADDRESS2:cc.event,
            # cc.EADDRESS3:cc.event,
            # cc.EADDRESS4:cc.event,
            # cc.EPOSTCODE:cc.event,
            # cc.EGRADER:cc.event,
            # cc.EGADDRESS1:cc.event,
            # cc.EGADDRESS2:cc.event,
            # cc.EGADDRESS3:cc.event,
            # cc.EGADDRESS4:cc.event,
            # cc.EGPOSTCODE:cc.event,
            # cc.EFIRSTMOVES:cc.event,
            # cc.EFIRSTMINUTES:cc.event,
            # cc.ENEXTMOVES:cc.event,
            # cc.ENEXTMINUTES:cc.event,
            # cc.ERESTMINUTES:cc.event,
            # cc.EALLMINUTES:cc.event,
            # cc.ESECPERMOVE:cc.event,
            # cc.EADJUDICATED:cc.event,
            # cc.EGRANDPRIX:cc.event,
            # cc.EFIDE:cc.event,
            # cc.ECHESSMOVES:cc.event,
            # cc.EEAST:cc.event,
            # cc.EMIDLAND:cc.event,
            # cc.ENORTH:cc.event,
            # cc.ESOUTH:cc.event,
            # cc.EWEST:cc.event,
            # cc.ECOLOR:cc.event,
            # cc.CCODE:{cc.club:None, cc.team:None, cc.affiliate:None},
            # cc.CNAME:cc.club,
            # cc.CBCF:cc.club,
            # cc.CBCFCOUNTY:cc.club,
            cc.PCODE: {
                cc.player: None,
                cc.affiliate: None,
                cc.represent: None,
            },
            cc.PNAME: {
                cc.player: None,
                cc.affiliate: None,
                cc.represent: None,
            },
            # cc.PBCF:cc.player,
            # cc.PDOB:cc.player,
            # cc.PGENDER:cc.player,
            # cc.PDIRECT:cc.player,
            # cc.PTITLE:cc.player,
            # cc.PFIDE:cc.player,
            cc.PLENFORENAME: cc.player,
            cc.PLENNICKNAME: cc.player,
            cc.MCODE: {cc.match: None, cc.game: None},
            cc.MNAME: cc.match,
            cc.MDATE: cc.match,
            cc.MTYPE: cc.match,
            cc.MCOLOR: cc.match,
            # cc.MUSEEVENTDATE:cc.match,
            cc.TCODE1: cc.match,
            cc.TCODE2: cc.match,
            cc.GROUND: cc.game,
            cc.GBOARD: cc.game,
            cc.GCODE: cc.game,
            cc.PCODE1: cc.game,
            cc.PCODE2: cc.game,
            cc.GCOLOR: cc.game,
            cc.GRESULT: cc.game,
            cc.GDATE: cc.game,
            # cc.GUSEMATCHDATE:cc.game,
            cc.TCODE: {cc.team: None, cc.represent: None},
            cc.TNAME: cc.team,
            # cc.RPAIRING:cc.represent,
            # cc.represent:None,
            # cc.club:None,
            cc.player: None,
            cc.game: None,
            # cc.affiliate:None,
            cc.team: None,
            cc.event: None,
            cc.match: None,
        }

        extract = super(ConvertLeagueDump, self).translate_results_format(
            context=context,
            keymap=keymap,
            validmap=validmap,
            pinreadmap={cc.PCODE, cc.PCODE1, cc.PCODE2},
            pinmap={cc.PCODE1, cc.PCODE2},
        )

        if not extract:
            return False

        gplayers = self.get_game_players()
        self.prune_players(gplayers)
        self.prune_affiliations(gplayers)
        del gplayers

        if not self.add_match_section_to_events():
            return False
        if not self.copy_event_and_player_identifiers_to_games():
            return False

        self.rebuild_player_data()
        self.set_team_names_and_affiliations()
        return extract

    def prune_affiliations(self, gameplayers):
        """Remove affiliation for players who have not played any games."""
        for e, p in list(self.affiliate.keys()):
            if p not in gameplayers:
                del self.affiliate[(e, p)]


class PhraseCounts(object):
    """Counts of phrase usage.

    The number of times the phrase equals starts or ends strings is updated
    by Add method. Phrases that start or end a string are candidate team
    names. Phrases that equal a string are likely match names.

    """

    def __init__(self, phrase):
        """Initialise counts which contribute to phrase weight."""
        super(PhraseCounts, self).__init__()
        self.phrase = tuple(phrase.split())
        self.chars = phrase
        self.equal = 0
        self.count = 0

    def __add__(self, increment):
        """Add increment to self.count contribution to phrase weight."""
        self.count += increment

    def get_weight(self):
        """Return weight assigned to phrase."""
        return (self.count, len(self.phrase))

    def __eq__(self, other):
        """Return True if defining attributea are equal."""
        if self.count != other.count:
            return False
        elif len(self.phrase) != len(other.phrase):
            return False
        elif self.chars != other.chars:
            return False
        return True

    def __ne__(self, other):
        """Return True if any defining attribute is not equal."""
        if self.count == other.count:
            return False
        elif len(self.phrase) == len(other.phrase):
            return False
        elif self.chars == other.chars:
            return False
        return True

    def __ge__(self, other):
        """Return True if defining attributes in order are greater or equal."""
        if self.count < other.count:
            return False
        elif len(self.phrase) < len(other.phrase):
            return False
        elif self.chars < other.chars:
            return False
        return True

    def __gt__(self, other):
        """Return True if defining attributes in order are greater."""
        if self.count <= other.count:
            return False
        elif len(self.phrase) <= len(other.phrase):
            return False
        elif self.chars <= other.chars:
            return False
        return True

    def __le__(self, other):
        """Return True if defining attributes in order are smaller or equal."""
        if self.count > other.count:
            return False
        elif len(self.phrase) > len(other.phrase):
            return False
        elif self.chars > other.chars:
            return False
        return True

    def __lt__(self, other):
        """Return True if defining attributes in order are smaller or equal."""
        if self.count >= other.count:
            return False
        elif len(self.phrase) >= len(other.phrase):
            return False
        elif self.chars >= other.chars:
            return False
        return True


def convert_date_to_iso(data, key):
    """Convert assumed dd/mm/yyyy to yyyy-mm-dd."""
    try:
        d = data[key].split("/")
        d.reverse()
        data[key] = "-".join(d)
    except:
        pass


def get_player_identifier_from_game(game, player, serial):
    """Return player identifier from game details."""
    return (
        game[cc._startdate],
        game[cc._enddate],
        game[cc._event],
        game[player],
        game[cc._section],
        game[serial],
    )


def single_splits(words=None):
    """Generate list of single splits of words excluding empty sequence.

    words can be a sequence of strings or a string to to be split
    into words delimited by whitespace

    single_splits('a b c') returns [('a', 'b c'), ('a b', 'c')]

    """
    if words is None:
        return set()
    elif isinstance(words, str):
        words = words.split()
    return [
        (" ".join(words[:i]), " ".join(words[i:]))
        for i in range(1, len(words))
    ]


class TeamNames(list):
    """Default team names for a match."""

    def __init__(self, matchname, teams):
        """Extend and deduce home and away team names."""
        super(TeamNames, self).__init__()
        self.append({cc._hometeam: "", cc._awayteam: ""})
        self.matchname = matchname

        for h, a in single_splits(words=matchname):
            f = {cc._hometeam: "", cc._awayteam: ""}
            for t in teams:
                if t in a:
                    if len(t) > len(f[cc._awayteam]):
                        f[cc._awayteam] = t
                if t in h:
                    if len(t) > len(f[cc._hometeam]):
                        f[cc._hometeam] = t
            if not f[cc._awayteam]:
                break
            if f[cc._hometeam]:
                self.append(f)

        if len(self) == 1:
            s = matchname.split()
            self[:] = [
                {
                    cc._hometeam: " ".join(s[: (1 + len(s)) // 2]),
                    cc._awayteam: " ".join(s[(1 + len(s)) // 2 :]),
                }
            ]
        else:
            del self[:-1]

    def __call__(self, team):
        """Return home or away team."""
        return self[-1][team]
